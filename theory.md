# Теоретическая часть 

## Условие задачи

На некоторой местности расположено несколько объектов, между которыми необходимо проложить дороги. Необходимо построить алгоритм, который принимает на вход расположение этих объектов и вычисляет такую карту дорог, в которой общая протяженность дорожного полотна минимальна.

## Подходы к решению задачи

Каждый объект будет однозначно задаваться двумя координатами в декартовой декартовой системе координат. Тогда можно вычислить расстояние от каждого объекта до всех других очевидным способом.

Таким образом, для удобства решения можно представить условие в виде взвешенного неориентированного графа, где каждой вершине соответствуют объекты, меджу всеми вершинами проведены рёбра, а вес каждого ребра определяется как расстояние между данными объектами.

### Формальная постановка задачи

Исходя из вышесказанного, задача сводится к нахождению минимального по весу остовного дерева в данном графе.  Данная задача принадлежит классу **P**, так как для неё существуют алгоритмы, решающие её за полиномиальное от количества вершин графа время. 

### Алгоритм Краскала

**Описание алгоритма**. В начале текущее множество рёбер устанавливается пустым. Затем, пока это возможно, проводится следующая операция: из всех рёбер, добавление которых к уже имеющемуся множеству не вызовет появление в нём цикла, выбирается ребро минимального веса и добавляется к уже имеющемуся множеству. Когда таких рёбер больше нет, алгоритм завершён.

**Оценка сложности**. Здесь и далее будем обозначать количество вершин через ***V***, а количество рёбер через ***E***. До начала работы алгоритма необходимо отсортировать рёбра по весу, это требует ***O(Elog(E))*** времени. Затем надо будет идти по отсортированным ребрам и добавлять их в ответ, если они не образуют цикл до тех пор, пока все вершины не будет покрыты. В худшем случае придётся пройти по всем ребрам, то есть сложность составит ***O(E)***. Тогда суммарная сложность алгоритма - ***O(Elog(E))***.

Как видно, сложность этого алгоритма зависит в основном только от количества рёбер, что может оказаться как плюсом, так и минусом в зависимости от задачи.

### Алгоритм Борувки

**Описание алгоритма**. Алгоритм состоит из нескольких шагов:
1. Изначально каждая вершина графа - тривиальное дерево **T**(состоит из одной вершины), а ребра не принадлежат никакому дереву.
2. Для каждого дерева **T** находится минимальное инцидентное ему ребро и добавляется к нему. На этом шаге происходит объединение деревьев, если появляется связывающее их ребро.
3. Шаг 2 повторяется пока в графе не останется только одно дерево **T**, которое и будет минимальным остовом.

Данный алгоритм может работать неправильно, если в графе есть ребра равные по весу. Избежать эту проблему можно, например, пронумеровав все ребра, тогда при равенстве весов будем выбирать ребро с наименьшим номером.

**Оценка сложности**. Очевидно, число деревьев **Т** на каждой итерации будет уменьшаться как минимум в два раза, то есть количество итераций - ***O(log(V))***. В каждой итерации в худшем случае необходимо проверить все рёбра, то есть сложность одной итерации - ***O(E)***. Таким образом, сложность всего алгоритма равна ***O(Elog(V))***.

### Алгоритм Прима

**Описание алгоритма**. Сначала берётся произвольная вершина и находится ребро, инцидентное данной вершине и обладающее наименьшей стоимостью. Найденное ребро и соединяемые им две вершины образуют дерево. Затем, рассматриваются рёбра графа, один конец которых — уже принадлежащая дереву вершина, а другой — нет; из этих рёбер выбирается ребро наименьшей стоимости. Выбираемое на каждом шаге ребро присоединяется к дереву. Рост дерева происходит до тех пор, пока не будут исчерпаны все вершины исходного графа.

**Оценка сложности**. Если хранить для каждой ещё не выбранной вершины минимальное ребро до дерева, полученного на данной итерации, то выбор нового ребра можно произвести из данных минимальных, что выполняется за ***O(V)***. Теперь для ещё не выбранных вершин надо выбрать минимальное ребро до полученного дерева. Так как мы храним минимальные ребра до дерева, которое было получено на предыдущем шаге, то на данном шаге либо останется то же ребро, либо ребро до последней добавленной вершины, если оно меньше по весу. Сложность этого этапа - ***O(V)***. Очевидно, что количество итераций - ***O(V)***. Таким образом, получаем, что сложность всего алгоритма алгоритма - ***O(V<sup>2</sup>)***.

## Выбор алгоритма
Так как в данной задаче граф будет являться полным, то количество рёбер выражается через количество вершин следующим образом:
```math
E = V(V-1)/2
```
То есть ***E = O(V<sup>2</sup>)***

В таком случае сложности принимают вид:
* алгоритм Краскала - ***O(V<sup>2</sup>log(V))***;
* алгоритм Борувки - ***O(V<sup>2</sup>log(V))***;
* алгоритм Прима - ***O(V<sup>2</sup>)***.

Исходя из этого будем решать задачу **алгоритмом Прима**.





# Теоретическая часть 

## Условие задачи

На некоторой местности расположено несколько объектов, между которыми необходимо проложить дороги. Необходимо построить алгоритм, который принимает на вход расположение этих объектов и вычисляет такую карту дорог, в которой общая протяженность дорожного полотна минимальна.

## Подходы к решению задачи

Каждый объект будет однозначно задаваться двумя координатами в декартовой декартовой системе координат. Тогда можно вычислить расстояние от каждого объекта до всех других очевидным способом.

Таким образом, для удобства решения можно представить условие в виде взвешенного неориентированного графа, где каждой вершине соответствуют объекты, меджу всеми вершинами проведены рёбра, а вес каждого ребра определяется как расстояние между данными объектами.

### Формальная постановка задачи

Так как не сказано, что дороги должны быть проложены только от одного из данных объектов до любого другого, то можно ставить промежуточные точки. Таким образом, задача сводится к задаче Штейнера на евклидовой плоскости. Доказано, что данная задача является ***NP-трудной***. Доказательство можно провести сведением задачи "Exact cover by 3-Sets(X3C)", лежащей в классе ***NPC***, к задаче Штейнера на графах.

Условие Х3С:

**Дано**: Конечное множество *Х = {х<sub>1</sub>,..., х<sub>3q</sub>}, |Х| = 3q*, набор *C = {C<sub>1</sub>,..., C<sub>n</sub>}* из 3-элементых подмножеств множества *Х*.

**Вопрос**: Содержит ли *С* точное покрытие *Х*, т.е набор подмножеств *С'* такой, что каждый элемент из *Х* содержится ровно в одном элементе из *С'*? Элементы множества *С'* формируют разбиение *Х*.

Построим граф для задачи Штейнера по условию X3C:

<img width="141" alt="Граф по X3C" src="https://user-images.githubusercontent.com/47656959/97813563-09ce7a00-1c9a-11eb-85a0-2ab578da8ed3.png">

Обозначив терминальными вершинами V и х<sub>1</sub>,..., х<sub>3q</sub> и дав всем ребрам вес 1, получим классическую задачу Штейнера на графах. 

Мы построили за полиномиальное время по условию задачи X3C условие для задачи Штейнера. И если теперь поставить вопрос в задаче Штейнера "существует ли дерево Штейнера весом меньше чем 4q", очевидно, что если ответ на X3C "да", то ответ на поставленный вопрос аналогичен. Таким образом, задача Штейнера в форме распознавания лежит в ***NPC***. Однако без этого "сужения" задача представлена в форме оптимизации и соответственно является ***NP-трудной***.

Дополнительная сложность нашей задачи заключается в том, что заданы только терминальные вершины и связи между ними, то есть необходимо перебрать все комбинации дополнительных точек, называемых точками Штейнера, имеющими следующие свойства:
* их количество <= количество терминальных точек - 2;
* их степень = 3;
* инцидентные им ребра образуют угол 120. 
 
### Алгоритм Краскала

**Описание алгоритма**. В начале текущее множество рёбер устанавливается пустым. Затем, пока это возможно, проводится следующая операция: из всех рёбер, добавление которых к уже имеющемуся множеству не вызовет появление в нём цикла, выбирается ребро минимального веса и добавляется к уже имеющемуся множеству. Когда таких рёбер больше нет, алгоритм завершён.

**Оценка сложности**. Здесь и далее будем обозначать количество вершин через ***V***, а количество рёбер через ***E***. До начала работы алгоритма необходимо отсортировать рёбра по весу, это требует ***O(Elog(E))*** времени. Затем надо будет идти по отсортированным ребрам и добавлять их в ответ, если они не образуют цикл до тех пор, пока все вершины не будет покрыты. В худшем случае придётся пройти по всем ребрам, то есть сложность составит ***O(E)***. Тогда суммарная сложность алгоритма - ***O(Elog(E))***.

Как видно, сложность этого алгоритма зависит в основном только от количества рёбер, что может оказаться как плюсом, так и минусом в зависимости от задачи.

### Алгоритм Борувки

**Описание алгоритма**. Алгоритм состоит из нескольких шагов:
1. Изначально каждая вершина графа - тривиальное дерево **T**(состоит из одной вершины), а ребра не принадлежат никакому дереву.
2. Для каждого дерева **T** находится минимальное инцидентное ему ребро и добавляется к нему. На этом шаге происходит объединение деревьев, если появляется связывающее их ребро.
3. Шаг 2 повторяется пока в графе не останется только одно дерево **T**, которое и будет минимальным остовом.

Данный алгоритм может работать неправильно, если в графе есть ребра равные по весу. Избежать эту проблему можно, например, пронумеровав все ребра, тогда при равенстве весов будем выбирать ребро с наименьшим номером.

**Оценка сложности**. Очевидно, число деревьев **Т** на каждой итерации будет уменьшаться как минимум в два раза, то есть количество итераций - ***O(log(V))***. В каждой итерации в худшем случае необходимо проверить все рёбра, то есть сложность одной итерации - ***O(E)***. Таким образом, сложность всего алгоритма равна ***O(Elog(V))***.

### Алгоритм, основанный на минимальном остовном дереве

**Описание алгоритма**. Будем строить минимальное остовное дерево с помощью алгоритма Прима. Сначала берётся произвольная вершина и находится ребро, инцидентное данной вершине и обладающее наименьшей стоимостью. Найденное ребро и соединяемые им две вершины образуют дерево. Затем, рассматриваются рёбра графа, один конец которых — уже принадлежащая дереву вершина, а другой — нет; из этих рёбер выбирается ребро наименьшей стоимости. Выбираемое на каждом шаге ребро присоединяется к дереву. Рост дерева происходит до тех пор, пока не будут исчерпаны все вершины исходного графа.

**Оценка сложности**. Если хранить для каждой ещё не выбранной вершины минимальное ребро до дерева, полученного на данной итерации, то выбор нового ребра можно произвести из данных минимальных, что выполняется за ***O(V)***. Теперь для ещё не выбранных вершин надо выбрать минимальное ребро до полученного дерева. Так как мы храним минимальные ребра до дерева, которое было получено на предыдущем шаге, то на данном шаге либо останется то же ребро, либо ребро до последней добавленной вершины, если оно меньше по весу. Сложность этого этапа - ***O(V)***. Очевидно, что количество итераций - ***O(V)***. Таким образом, получаем, что сложность всего алгоритма алгоритма - ***O(V<sup>2</sup>)***.

Что касается использования памяти, этот алгоритм требует хранения матрицы смежности, размер которой равен V<sup>2</sup>, также нужно хранить массивы использованных вершин, минимальных рёбер до уже построенного дерева, что будет иметь порядок ***O(V)***. Тогда суммарное использование памяти ***O(V<sup>2</sup>)***.

**Оценка точности**. Понятно, что данный алгоритм не ялвяется точным, так как не добавляет промежуточных точек, однако опытным путём доказано, что длина минимального остовного дерева менее чем, на 16% больше, чем длина минимального дерева Штейнера.

## Выбор алгоритма
Так как в данной задаче граф будет являться полным, то количество рёбер выражается через количество вершин следующим образом:
```math
E = V(V-1)/2
```
То есть ***E = O(V<sup>2</sup>)***

В таком случае сложности принимают вид:
* алгоритм Краскала - ***O(V<sup>2</sup>log(V))***;
* алгоритм Борувки - ***O(V<sup>2</sup>log(V))***;
* алгоритм Прима - ***O(V<sup>2</sup>)***.

Исходя из этого будем решать задачу **алгоритмом Прима**.






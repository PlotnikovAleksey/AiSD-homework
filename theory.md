# Теоретическая часть 

## Условие задачи

На некоторой местности расположено несколько объектов, между которыми необходимо проложить дороги. Необходимо построить алгоритм, который принимает на вход расположение этих объектов и вычисляет такую карту дорог, в которой общая протяженность дорожного полотна минимальна.

## Подходы к решению задачи

Каждый объект будет однозначно задаваться двумя координатами в декартовой декартовой системе координат. Тогда можно вычислить расстояние от каждого объекта до всех других очевидным способом.

Таким образом, для удобства решения можно представить условие в виде взвешенного неориентированного графа, где каждой вершине соответствуют объекты, меджу всеми вершинами проведены рёбра, а вес каждого ребра определяется как расстояние между данными объектами.

### Формальная постановка задачи

Исходя из вышесказанного, задача сводится к нахождению минимального по весу остовного дерева в данном графе.  Данная задача принадлежит классу **P**, так как для неё существуют алгоритмы, решающие её за полиномиальное от количества вершин графа время. 

### Алгоритм Краскала

**Описание алгоритма**. В начале текущее множество рёбер устанавливается пустым. Затем, пока это возможно, проводится следующая операция: из всех рёбер, добавление которых к уже имеющемуся множеству не вызовет появление в нём цикла, выбирается ребро минимального веса и добавляется к уже имеющемуся множеству. Когда таких рёбер больше нет, алгоритм завершён.

**Оценка сложности**. Здесь и далее будем обозначать количество вершин через *V*, а количество рёбер через *E*. До начала работы алгоритма необходимо отсортировать рёбра по весу, это требует *O(Elog(E))* времени. Затем надо будет идти по отсортированным ребрам и добавлять их в ответ, если они не образуют цикл до тех пор, пока все вершины не будет покрыты. В худшем случае придётся пройти по всем ребрам, то есть сложность составит *O(E)*. Тогда суммарная сложность алгоритма - *O(Elog(E))*.

Как видно, сложность этого алгоритма зависит в основном только от количества рёбер, что может оказаться как плюсом, так и минусом в зависимости от задачи.

### Алгоритм Борувки

**Описание алгоритма**. Алгоритм состоит из нескольких шагов:
1. Изначально каждая вершина графа - тривиальное дерево **T**(состоит из одной вершины), а ребра не принадлежат никакому дереву.
2. Для каждого дерева **T** находится минимальное инцидентное ему ребро и добавляется к нему. На этом шаге происходит объединение деревьев, если появляется связывающее их ребро.
3. Шаг 2 повторяется пока в графе не останется только одно дерево **T**, которое и будет минимальным остовом.

Данный алгоритм может работать неправильно, если в графе есть ребра равные по весу. Избежать эту проблему можно, например, пронумеровав все ребра, тогда при равенстве весов будем выбирать ребро с наименьшим номером.

**Оценка сложности**. Очевидно, число деревьев **Т** на каждой итерации будет уменьшаться как минимум в два раза, то есть количество итераций - *O(log(V))*. В каждой итерации в худшем случае необходимо проверить все рёбра, то есть сложность одной итерации - *O(E)*. Таким образом сложность всего алгоритма равна *O(Elog(V))*.
